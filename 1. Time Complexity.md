
# 시간 복잡도의 중요성
예시
- 1부터 n까지 더하는 알고리즘
- for loop를 구하여 1부터 n까지 더할 수 있음
	- 만약, n이 매우 큰 수라면? 시간이 너무 걸
- 수학적 공식을 사용하여 $n * (n+1) / 2$ 계산이 가능
- 따라서 시간 복잡도를 고려하여 알고리즘을 짜야 함

# 빅오 표기법 (Big-O)
- 각 알고리즘이 입력 n에 따라 가장 많은 연산을 할 경우, 점근적으로 어느 정도의 시간이 걸리는 지 추정하여 표기하는 방식을 뜻함
- 1부터 n까지 더하는 알고리즘의 경우, 최악의 경우 n에 비례하여 소요 시간이 걸림
	- O(n)
- 시간 복잡도의 알고리즘의 루프의 개수로 구할 수 있음
```python
# 이중 루프의 경우 O(n^2)

def loopTwice:
	answer=1
	for i in range(n+1):
		for j in range(n+1):
			answer += i * j
		return answer
```
- 힙 큐, 트리 등 알고리즘이 쓴 자료구조를 종합하여 계산하기도 함

# 입력 제한과 Big-O 표기법
- 코딩 테스트에는 입력 제한이 걸림
- 입력을 보고 이 문제가 뚫리는 빅-오 노테이션을 추정할 수 있음

> $n<=20$, 브루트 포스 (혹은 전탐색)

$n = 10$
$O(n!) = 3628800$
$10^8 = 1sec$

$n = 20$
$O(2^n) = 1048576$
$10^8 = 1sec$


> $n<=100$, 삼중 루프 통과, 플로이드-와샬 알고리즘
> - 그래프에서 모든 점들 간의 최단 거리를 구하는 알고리즘

$n = 100$
$O(n^3) = 10^6$
$10^8 = 1sec$

> $n <= 1000$, 이중 루프 통과, 벨만 포드 알고리즘
> - 거리에 음수가 있는 그래프에서 한 점과 나머지 점들의 최단 거리를 구하는 알고리즘

$n = 1000$
$O(n^2) = 10^6$
$10^8 = 1sec$

> $n<= 10000$, 동적 프로그래밍, 이분 탐색, 다익스트라 알고리즘, 유니언 파인드, 세그먼트 트리, 투 포인터
> - 큰 문제를 작은 문제로 쪼개고, 작은 문제의 답을 메모하여 문제를 푸는 기법
> - 탐색 범위를 절반씩 줄여 가며 해답을 찾는 기법
> - 거리가 모두 양수인 그래프에서 한 지점과 다른 모든 지점까지의 최단 거리를 찾는 알고리즘
> - 원소들을 서로 겹치지 않는 집합에 묶고 병합하는 알고리즘과 자료구조
> - 구간별 합이나 곱을 효과적으로 저장하는 트리 자료구조
> - 1차원 배열에서 두 인덱스를 저장하여 $O(n)$으로 계산하는 기법

$n = 10000$
$O(n) = 10000$
$O(nlogn) = 40000$
$10^8 = 1sec$

> $n <= 10^8$, 유클리드의 호제법
> - 두 자연수를 서로 나누어 최대공약수를 빠르게 구하는 기

$n = 10^8$
$O(logn) = 8$
$10^8 = 1sec$

# 입력 제한과 문제 풀이 추론
입력 제한 
- N이 최악의 경우 얼마까지 커지는가? (문제가 요구하는 시간복잡도를 미리 계산 가능)
- 입력 제한에 맞는 적절한 알고리즘을 끼워 맞추어 생각한다

입력 제한 예시 1
- 입력 제한이 $n<= 10000$
	- 이때 n은 1보다 크고 10000보다 작은 자연수이다
- $O(nlogn)$의 풀이만 효율성 검사를 통과할 수 있음

입력 제한 예시 2
- 입력 제한이 $n<= 100$
-  $O(n^3)$ 이상이면 효율성 검사를 통과할 수 있음

# 결론
- $10^8$은 1초이다.
- $10^8$가지 사실은 없다.

